<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>构建 类型 类型类 | Keep learning</title>
    <meta name="description" content="keep learning">
    
    
    <link rel="preload" href="/assets/css/0.styles.ef148202.css" as="style"><link rel="preload" href="/assets/js/app.67e7f428.js" as="script"><link rel="preload" href="/assets/js/23.9c246f12.js" as="script"><link rel="prefetch" href="/assets/js/10.9e81d398.js"><link rel="prefetch" href="/assets/js/11.677d4ba6.js"><link rel="prefetch" href="/assets/js/12.51d6780b.js"><link rel="prefetch" href="/assets/js/13.a1724e18.js"><link rel="prefetch" href="/assets/js/14.28dd4294.js"><link rel="prefetch" href="/assets/js/15.f2a7689f.js"><link rel="prefetch" href="/assets/js/16.cd9f0474.js"><link rel="prefetch" href="/assets/js/17.3640e356.js"><link rel="prefetch" href="/assets/js/18.0e89fc94.js"><link rel="prefetch" href="/assets/js/19.660c385c.js"><link rel="prefetch" href="/assets/js/2.c18e3c75.js"><link rel="prefetch" href="/assets/js/20.a70e4495.js"><link rel="prefetch" href="/assets/js/21.b7b4380c.js"><link rel="prefetch" href="/assets/js/22.7fe8571d.js"><link rel="prefetch" href="/assets/js/24.4ebab5c7.js"><link rel="prefetch" href="/assets/js/25.e0f6c8dc.js"><link rel="prefetch" href="/assets/js/26.667a1084.js"><link rel="prefetch" href="/assets/js/27.484b1e43.js"><link rel="prefetch" href="/assets/js/28.e08b6058.js"><link rel="prefetch" href="/assets/js/29.0901b7fb.js"><link rel="prefetch" href="/assets/js/3.1660a1d9.js"><link rel="prefetch" href="/assets/js/30.5c5cb9f5.js"><link rel="prefetch" href="/assets/js/31.381f1dec.js"><link rel="prefetch" href="/assets/js/32.8f68533f.js"><link rel="prefetch" href="/assets/js/33.74cd6521.js"><link rel="prefetch" href="/assets/js/34.9d137b36.js"><link rel="prefetch" href="/assets/js/35.50b3f97d.js"><link rel="prefetch" href="/assets/js/36.1ba216f1.js"><link rel="prefetch" href="/assets/js/37.39b36aaf.js"><link rel="prefetch" href="/assets/js/38.d86ece5f.js"><link rel="prefetch" href="/assets/js/39.ed51f794.js"><link rel="prefetch" href="/assets/js/4.46657140.js"><link rel="prefetch" href="/assets/js/40.d1f5f3e3.js"><link rel="prefetch" href="/assets/js/41.cfb412eb.js"><link rel="prefetch" href="/assets/js/42.4e699448.js"><link rel="prefetch" href="/assets/js/43.e22ec204.js"><link rel="prefetch" href="/assets/js/44.0421ffff.js"><link rel="prefetch" href="/assets/js/45.58b817ec.js"><link rel="prefetch" href="/assets/js/46.541083b5.js"><link rel="prefetch" href="/assets/js/5.12d27dc6.js"><link rel="prefetch" href="/assets/js/6.25c40935.js"><link rel="prefetch" href="/assets/js/7.0b9bcdd6.js"><link rel="prefetch" href="/assets/js/8.c8621244.js"><link rel="prefetch" href="/assets/js/9.5e4b7b3b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.ef148202.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Keep learning</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/haskell/" class="sidebar-link">简介</a></li><li><a href="/haskell/01.types.html" class="sidebar-link">基础类型</a></li><li><a href="/haskell/02.typeclass.html" class="sidebar-link">类型签名</a></li><li><a href="/haskell/03.function.html" class="sidebar-link">函数语法</a></li><li><a href="/haskell/04.recursion.html" class="sidebar-link">递归</a></li><li><a href="/haskell/05.high-order.html" class="sidebar-link">高阶函数</a></li><li><a href="/haskell/06.module.html" class="sidebar-link">模块</a></li><li><a href="/haskell/07.build-typeclass.html" class="active sidebar-link">构建 类型 类型类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#抽象数据类型" class="sidebar-link">抽象数据类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#构造函数与类型" class="sidebar-link">构造函数与类型</a></li><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#计算图形面积的函数" class="sidebar-link">计算图形面积的函数</a></li><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#deriving-派生" class="sidebar-link">deriving 派生</a></li><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#作为函数使用" class="sidebar-link">作为函数使用</a></li><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#使用子类型" class="sidebar-link">使用子类型</a></li><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#类型导出" class="sidebar-link">类型导出</a></li></ul></li><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#记录表达式" class="sidebar-link">记录表达式</a></li><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#类型参数" class="sidebar-link">类型参数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#添加类型约束" class="sidebar-link">添加类型约束</a></li></ul></li><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#派生实例" class="sidebar-link">派生实例</a></li><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#类型别名" class="sidebar-link">类型别名</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#类型别名也是可以有参数的" class="sidebar-link">类型别名也是可以有参数的</a></li><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#不全调用类型" class="sidebar-link">不全调用类型</a></li><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#either" class="sidebar-link">Either</a></li></ul></li><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#递归结构类型" class="sidebar-link">递归结构类型</a></li><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#类型类" class="sidebar-link">类型类</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#实现一个类型类" class="sidebar-link">实现一个类型类</a></li><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#子类型类" class="sidebar-link">子类型类</a></li><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#类型构造函数实现" class="sidebar-link">类型构造函数实现</a></li></ul></li><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#构建自己的类型类" class="sidebar-link">构建自己的类型类</a></li><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#函子类型类（functor-typeclass）" class="sidebar-link">函子类型类（Functor typeClass）</a></li><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#kind-（类型的类型）" class="sidebar-link">kind （类型的类型）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#kind-不完全调用" class="sidebar-link">kind 不完全调用</a></li><li class="sidebar-sub-header"><a href="/haskell/07.build-typeclass.html#练习" class="sidebar-link">练习</a></li></ul></li></ul></li><li><a href="/haskell/08.input-output.html" class="sidebar-link">输入输出</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="构建-类型-类型类"><a href="#构建-类型-类型类" aria-hidden="true" class="header-anchor">#</a> 构建 类型 类型类</h1> <h2 id="抽象数据类型"><a href="#抽象数据类型" aria-hidden="true" class="header-anchor">#</a> 抽象数据类型</h2> <p>我们可以使用 data 关键字来定义 类型</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token comment">-- Bool 在标准库中的定义</span>
<span class="token keyword">data</span> <span class="token constant">Bool</span> <span class="token operator">=</span> <span class="token constant">False</span> <span class="token operator">|</span> <span class="token constant">True</span>

<span class="token comment">-- Int</span>
<span class="token keyword">data</span> <span class="token constant">Int</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2147483648</span> <span class="token operator">|</span> <span class="token operator">-</span><span class="token number">2147483647</span> <span class="token operator">|</span> <span class="token operator">...</span> <span class="token operator">|</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token operator">...</span> <span class="token operator">|</span> <span class="token number">2147483647</span>
</code></pre></div><p>构造一个表示图形的类型， 假设包含圆和矩形</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Shape</span> <span class="token operator">=</span> <span class="token constant">Circle</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token operator">|</span> <span class="token constant">React</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token constant">Float</span>
</code></pre></div><h3 id="构造函数与类型"><a href="#构造函数与类型" aria-hidden="true" class="header-anchor">#</a> 构造函数与类型</h3> <p>data 类似java的class，通过等号后面构造函数，创建出对应类型的值对象，它的类型即为等号前面的类型<br>
一个类型，可以有多个值构造函数, 模式匹配时使用值构造函数进行匹配。</p> <p>类型 Circle， React 其实可以理解为构造函数 本质也是一个函数，它的类型为</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Circle</span>
<span class="token constant">Circle</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Shape</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">React</span>
<span class="token constant">React</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Shape</span>
</code></pre></div><h3 id="计算图形面积的函数"><a href="#计算图形面积的函数" aria-hidden="true" class="header-anchor">#</a> 计算图形面积的函数</h3> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">surface</span> <span class="token operator">::</span> <span class="token constant">Shape</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">surface</span> <span class="token punctuation">(</span><span class="token constant">Circle</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token hvariable">r</span> <span class="token operator">^</span> <span class="token number">2</span>
<span class="token hvariable">surface</span> <span class="token punctuation">(</span><span class="token constant">React</span> <span class="token hvariable">x1</span> <span class="token hvariable">y1</span> <span class="token hvariable">x2</span> <span class="token hvariable">y2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">abs</span> <span class="token operator">$</span> <span class="token hvariable">x2</span> <span class="token operator">-</span> <span class="token hvariable">x1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token builtin">abs</span> <span class="token operator">$</span> <span class="token hvariable">y2</span> <span class="token operator">-</span> <span class="token hvariable">y1</span><span class="token punctuation">)</span>
</code></pre></div><blockquote><p>需要注意的是这里不可以以写成 Circle -&gt; Float 因为 Circle 并不是真正的类型,类似不可以写 True -&gt; False
如果使用模式匹配针对的都是构造函数， 类似的包括之前用过的 [], False, 5, 他们都是构造函数只是不包含参数而已</p></blockquote> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">surface</span> <span class="token operator">$</span> <span class="token constant">Circle</span> <span class="token number">1</span> <span class="token number">1</span> <span class="token number">1</span>
<span class="token number">3.1415927</span>

<span class="token hvariable">surface</span> <span class="token operator">$</span> <span class="token constant">React</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">200</span> <span class="token number">100</span>
<span class="token number">20000.0</span>
</code></pre></div><h3 id="deriving-派生"><a href="#deriving-派生" aria-hidden="true" class="header-anchor">#</a> deriving 派生</h3> <p>如果要将Circle 输出到控制台， 我们可以让Circle 成为show类型类 的子类型 ( 使用 deriving（派生）)</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Shape</span> <span class="token operator">=</span> <span class="token constant">Circle</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token operator">|</span> <span class="token constant">Rectangle</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>

<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Circle</span> <span class="token number">10</span> <span class="token number">20</span> <span class="token number">5</span>
<span class="token constant">Circle</span> <span class="token number">10.0</span> <span class="token number">20.0</span> <span class="token number">5.0</span>
</code></pre></div><h3 id="作为函数使用"><a href="#作为函数使用" aria-hidden="true" class="header-anchor">#</a> 作为函数使用</h3> <p>因为构造函数也是函数，所以我们可以把它当成普通函数来使用</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token constant">Circle</span> <span class="token number">10</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token constant">Circle</span> <span class="token number">10.0</span> <span class="token number">20.0</span> <span class="token number">4.0</span><span class="token punctuation">,</span><span class="token constant">Circle</span> <span class="token number">10.0</span> <span class="token number">20.0</span> <span class="token number">5.0</span><span class="token punctuation">,</span><span class="token constant">Circle</span> <span class="token number">10.0</span> <span class="token number">20.0</span> <span class="token number">6.0</span><span class="token punctuation">,</span><span class="token constant">Circle</span> <span class="token number">10.0</span> <span class="token number">20.0</span> <span class="token number">6.0</span><span class="token punctuation">]</span>
</code></pre></div><h3 id="使用子类型"><a href="#使用子类型" aria-hidden="true" class="header-anchor">#</a> 使用子类型</h3> <p>我们还可以在定义类型的时候使用其它子类型</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Point</span> <span class="token operator">=</span> <span class="token constant">Point</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
<span class="token keyword">data</span> <span class="token constant">Shape</span> <span class="token operator">=</span> <span class="token constant">Point</span> <span class="token constant">Float</span> <span class="token operator">|</span> <span class="token constant">Rectangle</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code></pre></div><blockquote><p>这里Point 类型的构造函数和自己的类型名字相同，虽然名字相同但它们是两个东西， 一个是表示类型，一个为构造函数</p></blockquote> <p>计算函数做对应修改</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">surface</span> <span class="token operator">::</span> <span class="token constant">Shape</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">surface</span> <span class="token punctuation">(</span><span class="token constant">Circle</span> <span class="token hvariable">_</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token hvariable">r</span> <span class="token operator">^</span> <span class="token number">2</span>
<span class="token hvariable">surface</span> <span class="token punctuation">(</span><span class="token constant">Rectangle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token hvariable">x1</span> <span class="token hvariable">y1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token hvariable">x2</span> <span class="token hvariable">y2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">abs</span> <span class="token operator">$</span> <span class="token hvariable">x2</span> <span class="token operator">-</span> <span class="token hvariable">x1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token builtin">abs</span> <span class="token operator">$</span> <span class="token hvariable">y2</span> <span class="token operator">-</span> <span class="token hvariable">y1</span><span class="token punctuation">)</span>

</code></pre></div><p>还可以定义辅助函数来帮助创建</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">baseCircle</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Shape</span>
<span class="token hvariable">baseCircle</span> <span class="token hvariable">r</span> <span class="token operator">=</span> <span class="token constant">Circle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token hvariable">r</span>

<span class="token hvariable">baseRect</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Shape</span>
<span class="token hvariable">baseRect</span> <span class="token hvariable">width</span> <span class="token hvariable">height</span> <span class="token operator">=</span> <span class="token constant">Rectangle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token hvariable">width</span> <span class="token hvariable">height</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="类型导出"><a href="#类型导出" aria-hidden="true" class="header-anchor">#</a> 类型导出</h3> <p>类型的导出类似于模块的导出</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">module</span> <span class="token constant">Shapes</span>
<span class="token punctuation">(</span> <span class="token constant">Point</span><span class="token punctuation">(</span><span class="token operator">..</span><span class="token punctuation">)</span>
<span class="token punctuation">,</span> <span class="token constant">Shape</span><span class="token punctuation">(</span><span class="token operator">..</span><span class="token punctuation">)</span>
<span class="token punctuation">,</span> <span class="token hvariable">surface</span>
<span class="token punctuation">,</span> <span class="token hvariable">nudge</span>
<span class="token punctuation">,</span> <span class="token hvariable">baseCircle</span>
<span class="token punctuation">,</span> <span class="token hvariable">baseRect</span>
<span class="token punctuation">)</span> <span class="token keyword">where</span>
</code></pre></div><p>我们可以选择不导出任何 Shape 的值构函数，这一来使用我们模块的人就只能用辅助函数 baseCircle 和 baseRect 来得到 Shape 了。Data.Map 就是这一套，没有 Map.Map [(1,2),(3,4)] 而是使用Map.fromList 这样的辅助函数得到 map</p> <h2 id="记录表达式"><a href="#记录表达式" aria-hidden="true" class="header-anchor">#</a> 记录表达式</h2> <p>如果我们需要表述一个人的 姓、名、年龄、身高、电话号码等<br>
如果直接表示 <code>data Person = Person String String Int Float String String deriving (Show)</code> 在构建和取数据时会非常麻烦<br>
这时我们可以使用 Record</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Person</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token punctuation">{</span>
  <span class="token hvariable">firstName</span><span class="token operator">::</span> <span class="token constant">String</span><span class="token punctuation">,</span>
  <span class="token hvariable">lastName</span><span class="token operator">::</span> <span class="token constant">String</span><span class="token punctuation">,</span>
  <span class="token hvariable">age</span><span class="token operator">::</span> <span class="token constant">Int</span><span class="token punctuation">,</span>
  <span class="token hvariable">height</span><span class="token operator">::</span> <span class="token constant">Float</span><span class="token punctuation">,</span>
  <span class="token hvariable">phone</span><span class="token operator">::</span> <span class="token constant">String</span><span class="token punctuation">,</span>
  <span class="token hvariable">flavor</span><span class="token operator">::</span> <span class="token constant">String</span>
<span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code></pre></div><p>通过 Record Syntax，Haskell 会自动生这些函数：firstName, lastName, age, height, phoneNumber 和 flavor。</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token hvariable">flavor</span>
<span class="token hvariable">flavor</span> <span class="token operator">::</span> <span class="token constant">Person</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token hvariable">firstName</span>
<span class="token hvariable">firstName</span> <span class="token operator">::</span> <span class="token constant">Person</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
</code></pre></div><p>同时在构造方式和打印内容上也有区别</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Car</span> <span class="token operator">=</span> <span class="token constant">Car</span> <span class="token punctuation">{</span><span class="token hvariable">company</span> <span class="token operator">::</span> <span class="token constant">String</span><span class="token punctuation">,</span> <span class="token hvariable">model</span> <span class="token operator">::</span> <span class="token constant">String</span><span class="token punctuation">,</span> <span class="token hvariable">year</span> <span class="token operator">::</span> <span class="token constant">Int</span><span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Car</span> <span class="token punctuation">{</span><span class="token hvariable">year</span><span class="token operator">=</span><span class="token number">1967</span><span class="token punctuation">,</span> <span class="token hvariable">company</span><span class="token operator">=</span><span class="token string">&quot;Ford&quot;</span><span class="token punctuation">,</span> <span class="token hvariable">model</span><span class="token operator">=</span><span class="token string">&quot;Mustang&quot;</span><span class="token punctuation">}</span>
<span class="token constant">Car</span> <span class="token punctuation">{</span><span class="token hvariable">company</span> <span class="token operator">=</span> <span class="token string">&quot;Ford&quot;</span><span class="token punctuation">,</span> <span class="token hvariable">model</span> <span class="token operator">=</span> <span class="token string">&quot;Mustang&quot;</span><span class="token punctuation">,</span> <span class="token hvariable">year</span> <span class="token operator">=</span> <span class="token number">1967</span><span class="token punctuation">}</span>
</code></pre></div><h2 id="类型参数"><a href="#类型参数" aria-hidden="true" class="header-anchor">#</a> 类型参数</h2> <p>使用类型参数，在通过构造函数传入的参数的类型，决定了构造出的值的类型<br>
同时在使用类型时，可以通过传入类型参数，来决定构造函数传入的数据类型</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Nothing</span> <span class="token operator">|</span> <span class="token constant">Just</span> <span class="token hvariable">a</span>
</code></pre></div><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token string">&quot;Haha&quot;</span>
<span class="token constant">Just</span> <span class="token string">&quot;Haha&quot;</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">84</span>
<span class="token constant">Just</span> <span class="token number">84</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Just</span> <span class="token string">&quot;Haha&quot;</span>
<span class="token constant">Just</span> <span class="token string">&quot;Haha&quot;</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Just</span> <span class="token number">84</span>
<span class="token constant">Just</span> <span class="token number">84</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">t</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Maybe</span> <span class="token hvariable">t</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">10</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">Double</span>
<span class="token constant">Just</span> <span class="token number">10.0</span>
</code></pre></div><blockquote><p>这里 Nothing 的类型为 Maybe a，所以函数的参数类型 不论是Maybe Int 还是 Maybe Chart 都可以传入 Nothing
就像 5 可以是 Int 也可以是 Double， 空List [] 的类型是 [a]</p></blockquote> <p>使用类型参数，我们可以构造出不关心我们要处理的值的具体类型的数据类型，使我们的类型更加通用。<br>
比如说一个容器类型，就和适合定义为包含类型参数的类型，但是并不是所有类型都适合定义为需要传入类型参数的类型，比如用来描述具体对象的类型如Car</p> <h3 id="添加类型约束"><a href="#添加类型约束" aria-hidden="true" class="header-anchor">#</a> 添加类型约束</h3> <p>我们还可以在类型参数上加上类型约束，比如</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">k</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Map</span> <span class="token hvariable">k</span> <span class="token hvariable">v</span> <span class="token operator">=</span> <span class="token operator">...</span>
</code></pre></div><p>但是在haskell中并不建议这样去做，因为使用时不论我们需不需要用到约束我们都需要加上约束。其实完全可以在使用时加到类型签名中</p> <h2 id="派生实例"><a href="#派生实例" aria-hidden="true" class="header-anchor">#</a> 派生实例</h2> <p>类型类就是定义了某些行为的接口  （它与类不同，更加类似于接口）
比如 Eq 类就定义了判定相等性的行为，Int类型是它的实例，所以Int的值可以判断相等性</p> <p>前面提到的派生关键字 deriving, 可以在我们构建类型时自动地给我们的类型加上相应的行为<br>
它们一般都是基于构造函数来做的相应行为，比如Eq 比较大小，构造函数在前面的对应值的大小要小于后面的值,所以False 一定比 True 小</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Bool</span> <span class="token operator">=</span> <span class="token constant">False</span> <span class="token operator">|</span> <span class="token constant">True</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Ord</span><span class="token punctuation">)</span>

<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">True</span> `<span class="token builtin">compare</span>` <span class="token constant">False</span>
<span class="token constant">GT</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">True</span> <span class="token operator">&gt;</span> <span class="token constant">False</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">True</span> <span class="token operator">&lt;</span> <span class="token constant">False</span>
<span class="token constant">False</span>
</code></pre></div><p>而类似于 Just (*3) &gt; Just (<em>2) 这样的比较是不行的，因为</em>3 *2 都是函数，而函数不属于Ord类 不能比较</p> <h2 id="类型别名"><a href="#类型别名" aria-hidden="true" class="header-anchor">#</a> 类型别名</h2> <p>类型别名可以给类型提供了不同的名字，让我们的代码更容易理解<br>
在写类型签名时 <code>[Char]</code> 和 <code>String</code> 等价，可以互换。这就是由类型别名实现的。</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">type</span> <span class="token constant">String</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>

<span class="token keyword">type</span> <span class="token constant">PhoneNumber</span> <span class="token operator">=</span> <span class="token constant">String</span>
<span class="token keyword">type</span> <span class="token constant">Name</span> <span class="token operator">=</span> <span class="token constant">String</span>
<span class="token keyword">type</span> <span class="token constant">PhoneBook</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">Name</span><span class="token punctuation">,</span><span class="token constant">PhoneNumber</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token hvariable">inPhoneBook</span> <span class="token operator">::</span> <span class="token constant">Name</span> <span class="token operator">-&gt;</span> <span class="token constant">PhoneNumber</span> <span class="token operator">-&gt;</span> <span class="token constant">PhoneBook</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">inPhoneBook</span> <span class="token hvariable">name</span> <span class="token hvariable">pnumber</span> <span class="token hvariable">pbook</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">name</span><span class="token punctuation">,</span><span class="token hvariable">pnumber</span><span class="token punctuation">)</span> `<span class="token builtin">elem</span>` <span class="token hvariable">pbook</span>
</code></pre></div><p>这里如果不用类型别名，我们函数的类型声明就只能是 String -&gt; String -&gt; [(String ,String)] -&gt; Bool 了。在这里使用类型别名是为了让类型声明更加易读</p> <h3 id="类型别名也是可以有参数的"><a href="#类型别名也是可以有参数的" aria-hidden="true" class="header-anchor">#</a> 类型别名也是可以有参数的</h3> <p>比如想表示一个可以接受任意类型的list</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">type</span> <span class="token constant">AssocList</span> <span class="token hvariable">k</span> <span class="token hvariable">v</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">k</span><span class="token punctuation">,</span><span class="token hvariable">v</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre></div><h3 id="不全调用类型"><a href="#不全调用类型" aria-hidden="true" class="header-anchor">#</a> 不全调用类型</h3> <p>用不全的类型参数调用类型构造函数就可以得到一个不全调用的类型构造函数（类型构造函数不同于值构造函数，它是用于对类型的构造）</p> <p>如果我们要一个表示从整数到某东西间映射关系的类型</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">type</span> <span class="token constant">IntMap</span> <span class="token hvariable">v</span> <span class="token operator">=</span> <span class="token constant">Map</span> <span class="token constant">Int</span> <span class="token hvariable">v</span>

<span class="token comment">-- 或者</span>
<span class="token keyword">type</span> <span class="token constant">IntMap</span> <span class="token operator">=</span> <span class="token constant">Map</span> <span class="token constant">Int</span>
</code></pre></div><p>如果要使用它，你可以用 qualified import 来导入 Data.Map。这时，类型构造函数前面必须得加上模块名。所以应该写个 type IntMap = Map.Map Int</p> <blockquote><p>类型构造函数和值构造函数的区别, 类型构造函数是用来构造具体类型的(等号前面那个), 值构造函数用来构造类型所对的值(等号后面的)</p></blockquote> <h3 id="either"><a href="#either" aria-hidden="true" class="header-anchor">#</a> Either</h3> <p>Maybe 是最常见的表示可能失败的计算的类型了, 但是Maybe有一个不足就是它只能表示失败了，失败的原因是办法表示的，不能携带更多的信息<br>
当我们需要知道具体的原因的时候，就需要使用 Either了，它用 a 来表示可能的错误的类型，用 b 来表示一个成功运算的类型， 即错误一律用 Left 值构造函数，而结果一律用 Right</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Either</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token constant">Left</span> <span class="token hvariable">a</span> <span class="token operator">|</span> <span class="token constant">Right</span> <span class="token hvariable">b</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Ord</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">,</span> <span class="token constant">Show</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="递归结构类型"><a href="#递归结构类型" aria-hidden="true" class="header-anchor">#</a> 递归结构类型</h2> <p>当一个类型的构造函数使用了自己的类型时，它就是递归结构类型</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">List</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Empty</span> <span class="token operator">|</span> <span class="token constant">Cons</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token constant">List</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">,</span> <span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Ord</span><span class="token punctuation">)</span>
</code></pre></div><p>这里构造函数 Cons 的第二个参数使用了List a 类型，即list里面还可以放入list， 这个放入的list可以是 Empty 也可以是另一个list</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Empty</span>
<span class="token constant">Empty</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">5</span> `<span class="token constant">Cons</span>` <span class="token constant">Empty</span>
<span class="token constant">Cons</span> <span class="token number">5</span> <span class="token constant">Empty</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">4</span> `<span class="token constant">Cons</span>` <span class="token punctuation">(</span><span class="token number">5</span> `<span class="token constant">Cons</span>` <span class="token constant">Empty</span><span class="token punctuation">)</span>
<span class="token constant">Cons</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token constant">Cons</span> <span class="token number">5</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">3</span> `<span class="token constant">Cons</span>` <span class="token punctuation">(</span><span class="token number">4</span> `<span class="token constant">Cons</span>` <span class="token punctuation">(</span><span class="token number">5</span> `<span class="token constant">Cons</span>` <span class="token constant">Empty</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token constant">Cons</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token constant">Cons</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token constant">Cons</span> <span class="token number">5</span> <span class="token constant">Empty</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><h2 id="类型类"><a href="#类型类" aria-hidden="true" class="header-anchor">#</a> 类型类</h2> <p>类型类 类似于接口， 它定义了一些行为（如 比较 排序 打印）， 我们会把满足这类性质的类型定义为该类型类的实例<br>
typeClass 的行为是由定义的函数来描述</p> <p>Eq 的定义</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">class</span> <span class="token constant">Eq</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
  <span class="token punctuation">(</span><span class="token operator">==</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
  <span class="token punctuation">(</span><span class="token operator">/=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
  <span class="token comment">{-# MINIMAL (==) | (/=) #-}</span>
        <span class="token comment">-- Defined in ‘GHC.Classes’</span>
</code></pre></div><p>这里的 a 就是我在定义实例时的类型，minimal 是要实现的最少的函数</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">TrafficLight</span> <span class="token operator">=</span> <span class="token constant">Red</span> <span class="token operator">|</span> <span class="token constant">Yellow</span> <span class="token operator">|</span> <span class="token constant">Green</span>
</code></pre></div><h3 id="实现一个类型类"><a href="#实现一个类型类" aria-hidden="true" class="header-anchor">#</a> 实现一个类型类</h3> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">instance</span> <span class="token constant">Eq</span> <span class="token constant">TrafficLight</span> <span class="token keyword">where</span>
    <span class="token constant">Red</span> <span class="token operator">==</span> <span class="token constant">Red</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token constant">Green</span> <span class="token operator">==</span> <span class="token constant">Green</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token constant">Yellow</span> <span class="token operator">==</span> <span class="token constant">Yellow</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token hvariable">_</span> <span class="token operator">==</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">False</span>
</code></pre></div><p>在实现时我们使用 instance 关键字来定义 Eq的实例， 这里的TrafficLight就是class 那里的a<br>
这里我们只实现了 ==，这里也使用了模式匹配</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">instance</span> <span class="token constant">Show</span> <span class="token constant">TrafficLight</span> <span class="token keyword">where</span>
    <span class="token builtin">show</span> <span class="token constant">Red</span> <span class="token operator">=</span> <span class="token string">&quot;Red light&quot;</span>
    <span class="token builtin">show</span> <span class="token constant">Yellow</span> <span class="token operator">=</span> <span class="token string">&quot;Yellow light&quot;</span>
    <span class="token builtin">show</span> <span class="token constant">Green</span> <span class="token operator">=</span> <span class="token string">&quot;Green light&quot;</span>

<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Red</span> <span class="token operator">==</span> <span class="token constant">Red</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Red</span> <span class="token operator">==</span> <span class="token constant">Yellow</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Red</span> `<span class="token builtin">elem</span>` <span class="token punctuation">[</span><span class="token constant">Red</span><span class="token punctuation">,</span> <span class="token constant">Yellow</span><span class="token punctuation">,</span> <span class="token constant">Green</span><span class="token punctuation">]</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token constant">Red</span><span class="token punctuation">,</span> <span class="token constant">Yellow</span><span class="token punctuation">,</span> <span class="token constant">Green</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token constant">Red</span> <span class="token hvariable">light</span><span class="token punctuation">,</span><span class="token constant">Yellow</span> <span class="token hvariable">light</span><span class="token punctuation">,</span><span class="token constant">Green</span> <span class="token hvariable">light</span><span class="token punctuation">]</span>
</code></pre></div><h3 id="子类型类"><a href="#子类型类" aria-hidden="true" class="header-anchor">#</a> 子类型类</h3> <p>typeclass 定义成其他 typeclass 的 subclass（子类型类）</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">class</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Num</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
   <span class="token operator">...</span>
</code></pre></div><p>这里我们使用了类型约束， 类型约束（Eq a）可以在很多地方去使用。<br>
这里的表述就相当于，在一个类型实现Num类型类前，必须先实现Eq类型类
相当于我们在使用Num类型类的类型时，它的值默认是可以使用 == 作比较的</p> <h3 id="类型构造函数实现"><a href="#类型构造函数实现" aria-hidden="true" class="header-anchor">#</a> 类型构造函数实现</h3> <p>类似于Maybe这种 不是一个具体类型，而属于一个类型构造函数的,可以这样定义</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Eq</span> <span class="token punctuation">(</span><span class="token constant">Maybe</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token constant">Just</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token constant">Just</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span>
    <span class="token constant">Nothing</span> <span class="token operator">==</span> <span class="token constant">Nothing</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token hvariable">_</span> <span class="token operator">==</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">False</span>
</code></pre></div><p>我们可以先给类型构造函数传入一个参数，使之成为具体的类型 Maybe m<br>
同时我们要比较Maybe里面的元素相等， 所以对于参数m也必须是Eq类型类下的(Eq m)</p> <blockquote><p>这里需要注意区分, 类型类的类型约束是限制需要的子类型, 类型类实现的类型约束是限制要实现的类型的限制
使用:info 可以查看类型、类型类的信息</p></blockquote> <h2 id="构建自己的类型类"><a href="#构建自己的类型类" aria-hidden="true" class="header-anchor">#</a> 构建自己的类型类</h2> <p>通过类型类来实现javascript 的Boolean默认类型转换</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token comment">-- 定义类型类</span>
<span class="token keyword">class</span> <span class="token constant">YesNo</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
    <span class="token hvariable">yesno</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
</code></pre></div><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token comment">-- Int</span>
<span class="token keyword">instance</span> <span class="token constant">YesNo</span> <span class="token constant">Int</span> <span class="token keyword">where</span>
    <span class="token hvariable">yesno</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token constant">False</span>
    <span class="token hvariable">yesno</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">True</span>

<span class="token comment">-- [a]</span>
<span class="token keyword">instance</span> <span class="token constant">YesNo</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token keyword">where</span>
    <span class="token hvariable">yesno</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">False</span>
    <span class="token hvariable">yesno</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">True</span>

<span class="token comment">-- Bool</span>
<span class="token keyword">instance</span> <span class="token constant">YesNo</span> <span class="token constant">Bool</span> <span class="token keyword">where</span>
    <span class="token hvariable">yesno</span> <span class="token operator">=</span> <span class="token builtin">id</span>

<span class="token comment">-- Maybe a</span>
<span class="token keyword">instance</span> <span class="token constant">YesNo</span> <span class="token punctuation">(</span><span class="token constant">Maybe</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token hvariable">yesno</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token hvariable">yesno</span> <span class="token constant">Nothing</span> <span class="token operator">=</span> <span class="token constant">False</span>
</code></pre></div><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesno</span> <span class="token operator">$</span> <span class="token builtin">length</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesno</span> <span class="token string">&quot;haha&quot;</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesno</span> <span class="token string">&quot;&quot;</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesno</span> <span class="token operator">$</span> <span class="token constant">Just</span> <span class="token number">0</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesno</span> <span class="token constant">True</span>
<span class="token constant">True</span>
</code></pre></div><h2 id="函子类型类（functor-typeclass）"><a href="#函子类型类（functor-typeclass）" aria-hidden="true" class="header-anchor">#</a> 函子类型类（Functor typeClass）</h2> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">class</span> <span class="token constant">Functor</span> <span class="token hvariable">f</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
</code></pre></div><p>函子类型类描述的是可以被map的类型。<br>
它有点类似一个容器，接收一个方法和一个容器，通过方法映射容器值，然后返回另一个容器</p> <p>像Maybe这样的容器，是这样定义对functor的实现的</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token constant">Maybe</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token constant">Nothing</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
</code></pre></div><p>这里的Maybe 就是前面的f a, f b， 这里的f 它只对Just做出操作</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token number">200</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token number">400</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
</code></pre></div><p>对于Either这样有两个参数的类型， 我们需要先做一个不完全调用，放回需要一个参数的类型<br>
对于 Right 我们需要map，对于Left我们不需要map</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token punctuation">(</span><span class="token constant">Either</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Right</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Right</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Left</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Left</span> <span class="token hvariable">x</span>
</code></pre></div><p>至于为什么只对Right 做map，可以看下定义，它的Right才是包含值的，而Left仅仅是作为对错误的反馈</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Either</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token constant">Left</span> <span class="token hvariable">a</span> <span class="token operator">|</span> <span class="token constant">Right</span> <span class="token hvariable">b</span>
</code></pre></div><h2 id="kind-（类型的类型）"><a href="#kind-（类型的类型）" aria-hidden="true" class="header-anchor">#</a> kind （类型的类型）</h2> <p>类型构造函数接受其他类型作为他的参数，来构造出一个具体类型。这样的行为会让我们想到函数，也是接受一个值当作参数，并返回另一个值。<br>
任何值都有自己的类型，如 3 &quot;ok&quot; take 他们都有自己的类型，可以把类型看作一个标签，值会带着这个标签，这样我们就可以推断它的性质。</p> <p>但是类型它也有自己的标签 Kind， 它就是类型的类型， 我们可以用:k 来查询类型的Kind</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">k</span> <span class="token constant">Int</span>
<span class="token constant">Int</span> <span class="token operator">::</span> <span class="token operator">*</span>
</code></pre></div><p><code>*</code> 代表这个类型是具体类型， 这里Int是具体类型，所以它没有任何参数</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">k</span> <span class="token constant">Maybe</span>
<span class="token constant">Maybe</span> <span class="token operator">::</span> <span class="token operator">*</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span>

<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">k</span> <span class="token constant">Maybe</span> <span class="token constant">Int</span>
<span class="token constant">Maybe</span> <span class="token constant">Int</span> <span class="token operator">::</span> <span class="token operator">*</span>
</code></pre></div><p>而对于Maybe ，它需要接收另一个类型来构造出一个具体类型， 如 Maybe Int 它的类型就是 <code>*</code> 具体类型</p> <h3 id="kind-不完全调用"><a href="#kind-不完全调用" aria-hidden="true" class="header-anchor">#</a> kind 不完全调用</h3> <p>由于kind 也是函数，所以我们可以不完全调用它，来生成一个新的类型构造函数</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">k</span> <span class="token constant">Either</span>
<span class="token constant">Either</span> <span class="token operator">::</span> <span class="token operator">*</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span>

<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">k</span> <span class="token constant">Either</span> <span class="token constant">String</span>
<span class="token constant">Either</span> <span class="token constant">String</span> <span class="token operator">::</span> <span class="token operator">*</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">k</span> <span class="token constant">Either</span> <span class="token constant">String</span> <span class="token constant">Int</span>
<span class="token constant">Either</span> <span class="token constant">String</span> <span class="token constant">Int</span> <span class="token operator">::</span> <span class="token operator">*</span>
</code></pre></div><p>这里的Either 需要接收两个参数在返回一个类型，传入一个类型时返回了一个 <code>* -&gt; *</code> 构造函数</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">class</span> <span class="token constant">Functor</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token operator">::</span> <span class="token operator">*</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
  <span class="token builtin">fmap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
  <span class="token punctuation">(</span><span class="token operator">&lt;$</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span>
  <span class="token comment">{-# MINIMAL fmap #-}</span>
        <span class="token comment">-- Defined in ‘GHC.Base’</span>
</code></pre></div><p>回到前面的Functor 定义中，通过:info 查看Functor。这里如果要实现Functor的实例，需要传入的 f 类型的 kind 为 <code>* -&gt; *</code>,
对应到下面的fmap中, 这里的 f a 再传入一个参数就成了具体的类型了</p> <p>比如下面这个例子，t类型的kind就是 <code>* -&gt; (* -&gt; *) -&gt; *</code>, j 的kind 为 <code>* -&gt; *</code></p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">class</span> <span class="token constant">Tofu</span> <span class="token hvariable">t</span> <span class="token keyword">where</span>
    <span class="token hvariable">tofu</span> <span class="token operator">::</span> <span class="token hvariable">j</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">t</span> <span class="token hvariable">a</span> <span class="token hvariable">j</span>
</code></pre></div><h3 id="练习"><a href="#练习" aria-hidden="true" class="header-anchor">#</a> 练习</h3> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">data</span> <span class="token constant">Barry</span> <span class="token hvariable">t</span> <span class="token hvariable">k</span> <span class="token hvariable">p</span> <span class="token operator">=</span> <span class="token constant">Barry</span> <span class="token punctuation">{</span> <span class="token hvariable">yabba</span> <span class="token operator">::</span> <span class="token hvariable">p</span><span class="token punctuation">,</span> <span class="token hvariable">dabba</span> <span class="token operator">::</span> <span class="token hvariable">t</span> <span class="token hvariable">k</span> <span class="token punctuation">}</span>

<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">k</span> <span class="token constant">Barry</span>
<span class="token constant">Barry</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span>
</code></pre></div><p>这里的 Barry 接受三个类型参数，所以会是 <code>something -&gt; something -&gt; something -&gt; *</code>。p 是一个具体类型因此是 <code>*</code>。至于 k，我们假设他是 <code>*</code>，所以 t 会是 <code>* -&gt; *</code>。现在我们把这些代入 something，所以 kind 就变成 <code>(* -&gt; *) -&gt; * -&gt; * -&gt; *</code>。</p> <p>如果我们要把它定义为一个 Functor 的实例，我们必须先 partially apply 头两个类型参数，这样我们就会是 <code>* -&gt; *</code> 的 kind。这代表 instance 定义会是 instance Functor (Barry a b) where。如果我们看 fmap 针对 Barry 的类型，也就是把 f 代换成 Barry c d，那就会是 fmap :: (a -&gt; b) -&gt; Barry c d a -&gt; Barry c d b。第三个 Barry 的类型参数是对于任何类型, 我们把 f map 到第一个字段:</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token punctuation">(</span><span class="token constant">Barry</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Barry</span> <span class="token punctuation">{</span><span class="token hvariable">yabba</span> <span class="token operator">=</span> <span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token hvariable">dabba</span> <span class="token operator">=</span> <span class="token hvariable">y</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Barry</span> <span class="token punctuation">{</span><span class="token hvariable">yabba</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token hvariable">dabba</span> <span class="token operator">=</span> <span class="token hvariable">y</span><span class="token punctuation">}</span>
</code></pre></div></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/haskell/06.module.html" class="prev">
          模块
        </a></span> <span class="next"><a href="/haskell/08.input-output.html">
          输入输出
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.67e7f428.js" defer></script><script src="/assets/js/23.9c246f12.js" defer></script>
  </body>
</html>
