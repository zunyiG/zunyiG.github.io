<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>函数语法 | Keep learning</title>
    <meta name="description" content="keep learning">
    
    
    <link rel="preload" href="/assets/css/0.styles.ef148202.css" as="style"><link rel="preload" href="/assets/js/app.67e7f428.js" as="script"><link rel="preload" href="/assets/js/19.660c385c.js" as="script"><link rel="prefetch" href="/assets/js/10.9e81d398.js"><link rel="prefetch" href="/assets/js/11.677d4ba6.js"><link rel="prefetch" href="/assets/js/12.51d6780b.js"><link rel="prefetch" href="/assets/js/13.a1724e18.js"><link rel="prefetch" href="/assets/js/14.28dd4294.js"><link rel="prefetch" href="/assets/js/15.f2a7689f.js"><link rel="prefetch" href="/assets/js/16.cd9f0474.js"><link rel="prefetch" href="/assets/js/17.3640e356.js"><link rel="prefetch" href="/assets/js/18.0e89fc94.js"><link rel="prefetch" href="/assets/js/2.c18e3c75.js"><link rel="prefetch" href="/assets/js/20.a70e4495.js"><link rel="prefetch" href="/assets/js/21.b7b4380c.js"><link rel="prefetch" href="/assets/js/22.7fe8571d.js"><link rel="prefetch" href="/assets/js/23.9c246f12.js"><link rel="prefetch" href="/assets/js/24.4ebab5c7.js"><link rel="prefetch" href="/assets/js/25.e0f6c8dc.js"><link rel="prefetch" href="/assets/js/26.667a1084.js"><link rel="prefetch" href="/assets/js/27.484b1e43.js"><link rel="prefetch" href="/assets/js/28.e08b6058.js"><link rel="prefetch" href="/assets/js/29.0901b7fb.js"><link rel="prefetch" href="/assets/js/3.1660a1d9.js"><link rel="prefetch" href="/assets/js/30.5c5cb9f5.js"><link rel="prefetch" href="/assets/js/31.381f1dec.js"><link rel="prefetch" href="/assets/js/32.8f68533f.js"><link rel="prefetch" href="/assets/js/33.74cd6521.js"><link rel="prefetch" href="/assets/js/34.9d137b36.js"><link rel="prefetch" href="/assets/js/35.50b3f97d.js"><link rel="prefetch" href="/assets/js/36.1ba216f1.js"><link rel="prefetch" href="/assets/js/37.39b36aaf.js"><link rel="prefetch" href="/assets/js/38.d86ece5f.js"><link rel="prefetch" href="/assets/js/39.ed51f794.js"><link rel="prefetch" href="/assets/js/4.46657140.js"><link rel="prefetch" href="/assets/js/40.d1f5f3e3.js"><link rel="prefetch" href="/assets/js/41.cfb412eb.js"><link rel="prefetch" href="/assets/js/42.4e699448.js"><link rel="prefetch" href="/assets/js/43.e22ec204.js"><link rel="prefetch" href="/assets/js/44.0421ffff.js"><link rel="prefetch" href="/assets/js/45.58b817ec.js"><link rel="prefetch" href="/assets/js/46.541083b5.js"><link rel="prefetch" href="/assets/js/5.12d27dc6.js"><link rel="prefetch" href="/assets/js/6.25c40935.js"><link rel="prefetch" href="/assets/js/7.0b9bcdd6.js"><link rel="prefetch" href="/assets/js/8.c8621244.js"><link rel="prefetch" href="/assets/js/9.5e4b7b3b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.ef148202.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Keep learning</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/haskell/" class="sidebar-link">简介</a></li><li><a href="/haskell/01.types.html" class="sidebar-link">基础类型</a></li><li><a href="/haskell/02.typeclass.html" class="sidebar-link">类型签名</a></li><li><a href="/haskell/03.function.html" class="active sidebar-link">函数语法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/haskell/03.function.html#模式匹配" class="sidebar-link">模式匹配</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/haskell/03.function.html#模式匹配-参数" class="sidebar-link">模式匹配 -参数</a></li></ul></li><li class="sidebar-sub-header"><a href="/haskell/03.function.html#guards-守卫" class="sidebar-link">Guards (守卫)</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/haskell/03.function.html#where-关键字" class="sidebar-link">Where 关键字</a></li></ul></li><li class="sidebar-sub-header"><a href="/haskell/03.function.html#let-关键字" class="sidebar-link">let 关键字</a></li><li class="sidebar-sub-header"><a href="/haskell/03.function.html#case-语句" class="sidebar-link">case 语句</a></li></ul></li><li><a href="/haskell/04.recursion.html" class="sidebar-link">递归</a></li><li><a href="/haskell/05.high-order.html" class="sidebar-link">高阶函数</a></li><li><a href="/haskell/06.module.html" class="sidebar-link">模块</a></li><li><a href="/haskell/07.build-typeclass.html" class="sidebar-link">构建 类型 类型类</a></li><li><a href="/haskell/08.input-output.html" class="sidebar-link">输入输出</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="函数语法"><a href="#函数语法" aria-hidden="true" class="header-anchor">#</a> 函数语法</h1> <h2 id="模式匹配"><a href="#模式匹配" aria-hidden="true" class="header-anchor">#</a> 模式匹配</h2> <p>在定义函数时，你可以为不同的模式分别定义同一函数，你可以使用模式匹配一切数据类型 --- 数字，字符，List，元组，等等</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">lucky</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Integral</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">lucky</span> <span class="token number">7</span> <span class="token operator">=</span> <span class="token string">&quot;LUCKY NUMBER SEVEN!&quot;</span>
<span class="token hvariable">lucky</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token string">&quot;Sorry, you're out of luck, pal!&quot;</span>
</code></pre></div><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">factorial</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Integral</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">factorial</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token hvariable">factorial</span> <span class="token hvariable">n</span> <span class="token operator">=</span> <span class="token hvariable">n</span> <span class="token operator">*</span> <span class="token hvariable">factorial</span> <span class="token punctuation">(</span><span class="token hvariable">n</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code></pre></div><p>使用注意事项:</p> <ul><li>匹配至上而下，如果前面已经被匹配，后面的函数就不会再被匹配到了</li> <li>在定义模式时最好在末尾保留一个最全的匹配，以防匹配不到出现错误</li></ul> <h3 id="模式匹配-参数"><a href="#模式匹配-参数" aria-hidden="true" class="header-anchor">#</a> 模式匹配 -参数</h3> <h4 id="匹配-tuple（元祖）"><a href="#匹配-tuple（元祖）" aria-hidden="true" class="header-anchor">#</a> 匹配 Tuple（元祖）</h4> <p>只需要将两个参数都写成 Tuple 的形式就会进行模式匹配</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">addVectors</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">addVectors</span> <span class="token punctuation">(</span><span class="token hvariable">x1</span><span class="token punctuation">,</span> <span class="token hvariable">y1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">x2</span><span class="token punctuation">,</span> <span class="token hvariable">y2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x1</span> <span class="token operator">+</span> <span class="token hvariable">x2</span><span class="token punctuation">,</span> <span class="token hvariable">y1</span> <span class="token operator">+</span> <span class="token hvariable">y2</span><span class="token punctuation">)</span>
</code></pre></div><h4 id="忽略参数"><a href="#忽略参数" aria-hidden="true" class="header-anchor">#</a> 忽略参数 _</h4> <p>_ 就和 List Comprehension 中一样。表示我们不关心这部分的具体内容</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">first</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">first</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">x</span>

<span class="token hvariable">second</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span>
<span class="token hvariable">second</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">y</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">y</span>

<span class="token hvariable">third</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span>
<span class="token hvariable">third</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">z</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">z</span>
</code></pre></div><h4 id="list-comprehension（集合）-中使用"><a href="#list-comprehension（集合）-中使用" aria-hidden="true" class="header-anchor">#</a> List Comprehension（集合） 中使用</h4> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token operator">+</span><span class="token hvariable">b</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
</code></pre></div><p>一旦模式匹配失败，它就简单挪到下个元素。</p> <p>当然 List 本身也可以使用模式匹配。你可以用 [] 或 : 来匹配它，
因为 [1,2,3] 本质就是 1:2:3:[] 的语法糖, 所以像 x:xs 这样的模式可以将 List 的头部绑定为 x，尾部绑定为 xs</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token builtin">head</span>' <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">head</span>' <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">&quot;Can't call head on an empty list, dummy!&quot;</span>
<span class="token builtin">head</span>' <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">x</span>
</code></pre></div><p>匹配是必须使用() 括起来， 匹配到 [] 我们返回了一个运行时错误，这会让程序中断退出，酌情使用。</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token builtin">length</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span>
<span class="token builtin">length</span>' <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token builtin">length</span>' <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token builtin">length</span>' <span class="token hvariable">xs</span>
</code></pre></div><blockquote><p><code>x:xs</code> 这模式的应用非常广泛，尤其是递归函数。不过要注意的是它只能匹配长度大于等于 1 的 List</p></blockquote> <h4 id="as"><a href="#as" aria-hidden="true" class="header-anchor">#</a> as -- @</h4> <p>as 就是将一个名字和 @ 置于模式前，可以在按模式分割什么东西时仍保留对其整体的引用。如这个模式 xs@(x:y:ys)，它会匹配出与 x:y:ys 对应的东西，同时你也可以方便地通过 xs 得到整个 List，而不必在函数体中重复 x:y:ys</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">capital</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">capital</span> <span class="token string">&quot;&quot;</span> <span class="token operator">=</span> <span class="token string">&quot;Empty string, whoops!&quot;</span>
<span class="token hvariable">capital</span> <span class="token builtin">all</span><span class="token operator">@</span><span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">&quot;The first letter of &quot;</span> <span class="token operator">++</span> <span class="token builtin">all</span> <span class="token operator">++</span> <span class="token string">&quot; is &quot;</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span>
</code></pre></div><h2 id="guards-守卫"><a href="#guards-守卫" aria-hidden="true" class="header-anchor">#</a> Guards (守卫)</h2> <p>如果说模式用来检查一个值是否合适并从中取值，那么 guard 则用来检查一个值的某项属性是否为真， 其实就是类似 if 语句。但是它能提高代码的可读性，并且能和模式匹配很好的契合。</p> <p>先看一个计算 BMI 的函数</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">bmiTell</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">bmiTell</span> <span class="token hvariable">bmi</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token number">18.5</span> <span class="token operator">=</span> <span class="token string">&quot;You're underweight, you emo, you!&quot;</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token number">25.0</span> <span class="token operator">=</span> <span class="token string">&quot;You're supposedly normal. Pffft, I bet you're ugly!&quot;</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token number">30.0</span> <span class="token operator">=</span> <span class="token string">&quot;You're fat! Lose some weight, fatty!&quot;</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span>   <span class="token operator">=</span> <span class="token string">&quot;You're a whale, congratulations!&quot;</span>
</code></pre></div><p>guard 由跟在函数名及参数后面的竖线标志，通常他们都是靠右一个缩进排成一列。一个 guard 就是一个布尔表达式，如果为真，就使用其对应的函数体。如果为假，就继续执行一个 guard，最后的那个 guard 往往都是 otherwise，它的定义就是简单一个 otherwise = True ，捕获一切<br>
如果一个函数的所有 guard 都没有通过(而且没有提供 otherwise 作万能匹配)，就转入下一模式。这便是 guard 与模式契合的地方</p> <p>当然，guard 可以在含有任意数量参数的函数中使用。</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token builtin">max</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">max</span>' <span class="token hvariable">a</span> <span class="token hvariable">b</span>
    <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token operator">&gt;</span> <span class="token hvariable">b</span>     <span class="token operator">=</span> <span class="token hvariable">a</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token hvariable">b</span>
</code></pre></div><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">myCompare</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Ordering</span>
<span class="token hvariable">a</span> <span class="token operator">`myCompare`</span> <span class="token hvariable">b</span>
    <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token operator">&gt;</span> <span class="token hvariable">b</span>     <span class="token operator">=</span> <span class="token constant">GT</span>
    <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token operator">==</span> <span class="token hvariable">b</span>    <span class="token operator">=</span> <span class="token constant">EQ</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token constant">LT</span>
</code></pre></div><blockquote><p>通过反单引号，我们不仅可以以中缀形式调用函数，也可以在定义函数的时候使用它。有时这样会更易读。</p></blockquote> <h3 id="where-关键字"><a href="#where-关键字" aria-hidden="true" class="header-anchor">#</a> Where 关键字</h3> <p>where 关键字跟在 guard 后面(最好是与竖线缩进一致)，可以定义多个名字和函数。这些名字对每个 guard 都是可见的</p> <p>所以我们可以将之前的 bmi 函数修改为：</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">bmiTell</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">bmiTell</span> <span class="token hvariable">weight</span> <span class="token hvariable">height</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token number">18.5</span> <span class="token operator">=</span> <span class="token string">&quot;You're underweight, you emo, you!&quot;</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token number">25.0</span> <span class="token operator">=</span> <span class="token string">&quot;You're supposedly normal. Pffft, I bet you're ugly!&quot;</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token number">30.0</span> <span class="token operator">=</span> <span class="token string">&quot;You're fat! Lose some weight, fatty!&quot;</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span>   <span class="token operator">=</span> <span class="token string">&quot;You're a whale, congratulations!&quot;</span>
    <span class="token keyword">where</span> <span class="token hvariable">bmi</span> <span class="token operator">=</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span>
</code></pre></div><p>通过命名，我们提升了代码的可读性，并且由于 bmi 只计算了一次，函数的运行效率也有所提升。我们可以再做下修改：</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">bmiTell</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">bmiTell</span> <span class="token hvariable">weight</span> <span class="token hvariable">height</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token hvariable">skinny</span> <span class="token operator">=</span> <span class="token string">&quot;You're underweight, you emo, you!&quot;</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token hvariable">normal</span> <span class="token operator">=</span> <span class="token string">&quot;You're supposedly normal. Pffft, I bet you're ugly!&quot;</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token hvariable">fat</span>    <span class="token operator">=</span> <span class="token string">&quot;You're fat! Lose some weight, fatty!&quot;</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span>     <span class="token operator">=</span> <span class="token string">&quot;You're a whale, congratulations!&quot;</span>
    <span class="token keyword">where</span> <span class="token hvariable">bmi</span> <span class="token operator">=</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span>
          <span class="token hvariable">skinny</span> <span class="token operator">=</span> <span class="token number">18.5</span>
          <span class="token hvariable">normal</span> <span class="token operator">=</span> <span class="token number">25.0</span>
          <span class="token hvariable">fat</span> <span class="token operator">=</span> <span class="token number">30.0</span>
</code></pre></div><p>函数在 where 绑定中定义的名字只对本函数可见，因此我们不必担心它会污染其他函数的命名空间<br>
where 绑定不会在多个模式中共享。如果你在一个函数的多个模式中重复用到同一名字，就应该把它置于全局定义之中。</p> <p>在 where 中也可以使用模式匹配,所以我们可以进一步更改为：</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token operator">...</span>
<span class="token keyword">where</span> <span class="token hvariable">bmi</span> <span class="token operator">=</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span>
      <span class="token punctuation">(</span><span class="token hvariable">skinny</span><span class="token punctuation">,</span> <span class="token hvariable">normal</span><span class="token punctuation">,</span> <span class="token hvariable">fat</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">18.5</span><span class="token punctuation">,</span> <span class="token number">25.0</span><span class="token punctuation">,</span> <span class="token number">30.0</span><span class="token punctuation">)</span>
</code></pre></div><p>当然 where 也可以单独使用:</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">initials</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">initials</span> <span class="token hvariable">firstname</span> <span class="token hvariable">lastname</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">f</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token string">&quot;. &quot;</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token hvariable">l</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token string">&quot;.&quot;</span>
    <span class="token keyword">where</span> <span class="token punctuation">(</span><span class="token hvariable">f</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">firstname</span>
          <span class="token punctuation">(</span><span class="token hvariable">l</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">lastname</span>
</code></pre></div><p>where 还可以定义函数,<br>
这里是计算一组 bmi 的函数：</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">calcBmis</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">calcBmis</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">bmi</span> <span class="token hvariable">w</span> <span class="token hvariable">h</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token hvariable">w</span><span class="token punctuation">,</span> <span class="token hvariable">h</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span><span class="token punctuation">]</span>
    <span class="token keyword">where</span> <span class="token hvariable">bmi</span> <span class="token hvariable">weight</span> <span class="token hvariable">height</span> <span class="token operator">=</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span>
</code></pre></div><p>另外，where 绑定还可以一层套一层地来使用。 有个常见的写法是，在定义一个函数的时候也写几个辅助函数摆在 where 绑定中。 而每个辅助函数也可以透过 where 拥有各自的辅助函数</p> <h2 id="let-关键字"><a href="#let-关键字" aria-hidden="true" class="header-anchor">#</a> let 关键字</h2> <p>let 与 where 类似，where 是在函数底部定义名字，对包括所有 guard 在内的整个函数可见。let 则是个表达式，允许你在任何位置定义局部变量，而对不同的 guard 不可见。和 Haskell 其它赋值结构一样，let 绑定也可以使用模式匹配。<br>
let 的格式为 let [bindings] in [expressions]。在 let 中绑定的名字仅对 in 部分可见。</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">cylinder</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">cylinder</span> <span class="token hvariable">r</span> <span class="token hvariable">h</span> <span class="token operator">=</span>
    <span class="token keyword">let</span> <span class="token hvariable">sideArea</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token hvariable">r</span> <span class="token operator">*</span> <span class="token hvariable">h</span>
        <span class="token hvariable">topArea</span> <span class="token operator">=</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token hvariable">r</span> <span class="token operator">^</span><span class="token number">2</span>
    <span class="token keyword">in</span>  <span class="token hvariable">sideArea</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token hvariable">topArea</span>
</code></pre></div><p>与 where 不同之处在于，let 绑定本身是个表达式，而 where 绑定则是个语法结构<br>
所以 let 可以定义变量，也可以用作定义局部函数</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token number">9</span> <span class="token keyword">in</span> <span class="token hvariable">a</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span>
<span class="token number">42</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token keyword">let</span> <span class="token hvariable">square</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">x</span> <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token hvariable">square</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token hvariable">square</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token hvariable">square</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token number">300</span> <span class="token keyword">in</span> <span class="token hvariable">a</span><span class="token operator">*</span><span class="token hvariable">b</span><span class="token operator">*</span><span class="token hvariable">c</span><span class="token punctuation">,</span> <span class="token keyword">let</span> <span class="token hvariable">foo</span><span class="token operator">=</span><span class="token string">&quot;Hey &quot;</span><span class="token punctuation">;</span> <span class="token hvariable">bar</span> <span class="token operator">=</span> <span class="token string">&quot;there!&quot;</span> <span class="token keyword">in</span> <span class="token hvariable">foo</span> <span class="token operator">++</span> <span class="token hvariable">bar</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">6000000</span><span class="token punctuation">,</span><span class="token string">&quot;Hey there!&quot;</span><span class="token punctuation">)</span>
</code></pre></div><p>let 中也可以使用模式匹配</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token hvariable">a</span><span class="token operator">+</span><span class="token hvariable">b</span><span class="token operator">+</span><span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span>
<span class="token number">600</span>
</code></pre></div><p>可以将计算 bmi 的函数重新为更简单的形式：</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">calcBmis</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">calcBmis</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">bmi</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token hvariable">w</span><span class="token punctuation">,</span> <span class="token hvariable">h</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span><span class="token punctuation">,</span> <span class="token keyword">let</span> <span class="token hvariable">bmi</span> <span class="token operator">=</span> <span class="token hvariable">w</span> <span class="token operator">/</span> <span class="token hvariable">h</span> <span class="token operator">^</span> <span class="token number">2</span><span class="token punctuation">]</span>
</code></pre></div><p>List Comprehension 中 let 绑定的样子和限制条件差不多，只不过它做的不是过滤，而是绑定名字。let 中绑定的名字在输出函数及限制条件中都可见，需要注意的是在 (w, h) &lt;- xs 这里无法使用 bmi 这个变量，因为它在 let 绑定的前面。</p> <p>在 List Comprehension 中我们忽略了 let 的 in 部分，因为变量的可见性已经预先定义好了。不过，把一个 let...in 放到限制条件中也是可以的，这样变量只对这个限制条件可见。在 ghci 中 in 部分也可以省略，变量的定义就在整个环境中可见。</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">zoot</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token hvariable">z</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span> <span class="token operator">+</span> <span class="token hvariable">z</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">zoot</span> <span class="token number">3</span> <span class="token number">9</span> <span class="token number">2</span>
<span class="token number">29</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">boot</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token hvariable">z</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span> <span class="token operator">+</span> <span class="token hvariable">z</span> <span class="token keyword">in</span> <span class="token hvariable">boot</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">2</span>
<span class="token number">14</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">boot</span>
<span class="token operator">&lt;</span> <span class="token hvariable">interactive</span><span class="token operator">&gt;:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token operator">:</span> <span class="token constant">Not</span> <span class="token keyword">in</span> <span class="token hvariable">scope</span><span class="token operator">:</span> `<span class="token hvariable">boot</span>'
</code></pre></div><p>既然说 let 已经这么好了，还要 where 干嘛呢？嗯，let 是个表达式，定义域限制的相当小，因此不能在多个 guard 中使用。一些朋友更喜欢 where，因为它是跟在函数体后面，把主函数体距离类型声明近一些会更易读。</p> <h2 id="case-语句"><a href="#case-语句" aria-hidden="true" class="header-anchor">#</a> case 语句</h2> <p>case 是跟 if..else 和 let 一样的表达式。用它可以对变量的不同情况分别求值，还可以使用模式匹配。</p> <p>函数定义时参数的模式匹配本质上不过就是 case 语句的语法糖而已。所以下面这两段代码就是完全等价的：</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token builtin">head</span>' <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">head</span>' <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">&quot;No head for empty lists!&quot;</span>
<span class="token builtin">head</span>' <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">x</span>
</code></pre></div><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token builtin">head</span>' <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">head</span>' <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token keyword">case</span> <span class="token hvariable">xs</span> <span class="token keyword">of</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token builtin">error</span> <span class="token string">&quot;No head for empty lists!&quot;</span>
                      <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span>
</code></pre></div><p>expression 匹配合适的模式。 一如预期地，第一个模式若匹配，就运行第一个区块的代码；否则就接下去比对下一个模式。如果到最后依然没有匹配的模式，就会产生运行时错误。</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">case</span> <span class="token hvariable">expression</span> <span class="token keyword">of</span> <span class="token hvariable">pattern</span> <span class="token operator">-&gt;</span> <span class="token hvariable">result</span>
                   <span class="token hvariable">pattern</span> <span class="token operator">-&gt;</span> <span class="token hvariable">result</span>
                   <span class="token hvariable">pattern</span> <span class="token operator">-&gt;</span> <span class="token hvariable">result</span>
                   <span class="token operator">...</span>
</code></pre></div><p>与函数的匹配不同的是， 函数参数的模式匹配只能在定义函数时使用，而 case 表达式可以用在任何地方：</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">describeList</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">describeList</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token string">&quot;The list is &quot;</span> <span class="token operator">++</span> <span class="token keyword">case</span> <span class="token hvariable">xs</span> <span class="token keyword">of</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;empty.&quot;</span>
                                               <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;a singleton list.&quot;</span>
                                               <span class="token hvariable">xs</span> <span class="token operator">-&gt;</span> <span class="token string">&quot;a longer list.&quot;</span>
</code></pre></div><p>同样等价于下面这种写法：</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">describeList</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">describeList</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token string">&quot;The list is &quot;</span> <span class="token operator">++</span> <span class="token hvariable">what</span> <span class="token hvariable">xs</span>
    <span class="token keyword">where</span> <span class="token hvariable">what</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;empty.&quot;</span>
          <span class="token hvariable">what</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">&quot;a singleton list.&quot;</span>
          <span class="token hvariable">what</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token string">&quot;a longer list.&quot;</span>
</code></pre></div></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/haskell/02.typeclass.html" class="prev">
          类型签名
        </a></span> <span class="next"><a href="/haskell/04.recursion.html">
          递归
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.67e7f428.js" defer></script><script src="/assets/js/19.660c385c.js" defer></script>
  </body>
</html>
