<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>输入输出 | Keep learning</title>
    <meta name="description" content="keep learning">
    
    
    <link rel="preload" href="/assets/css/0.styles.ef148202.css" as="style"><link rel="preload" href="/assets/js/app.67e7f428.js" as="script"><link rel="preload" href="/assets/js/24.4ebab5c7.js" as="script"><link rel="prefetch" href="/assets/js/10.9e81d398.js"><link rel="prefetch" href="/assets/js/11.677d4ba6.js"><link rel="prefetch" href="/assets/js/12.51d6780b.js"><link rel="prefetch" href="/assets/js/13.a1724e18.js"><link rel="prefetch" href="/assets/js/14.28dd4294.js"><link rel="prefetch" href="/assets/js/15.f2a7689f.js"><link rel="prefetch" href="/assets/js/16.cd9f0474.js"><link rel="prefetch" href="/assets/js/17.3640e356.js"><link rel="prefetch" href="/assets/js/18.0e89fc94.js"><link rel="prefetch" href="/assets/js/19.660c385c.js"><link rel="prefetch" href="/assets/js/2.c18e3c75.js"><link rel="prefetch" href="/assets/js/20.a70e4495.js"><link rel="prefetch" href="/assets/js/21.b7b4380c.js"><link rel="prefetch" href="/assets/js/22.7fe8571d.js"><link rel="prefetch" href="/assets/js/23.9c246f12.js"><link rel="prefetch" href="/assets/js/25.e0f6c8dc.js"><link rel="prefetch" href="/assets/js/26.667a1084.js"><link rel="prefetch" href="/assets/js/27.484b1e43.js"><link rel="prefetch" href="/assets/js/28.e08b6058.js"><link rel="prefetch" href="/assets/js/29.0901b7fb.js"><link rel="prefetch" href="/assets/js/3.1660a1d9.js"><link rel="prefetch" href="/assets/js/30.5c5cb9f5.js"><link rel="prefetch" href="/assets/js/31.381f1dec.js"><link rel="prefetch" href="/assets/js/32.8f68533f.js"><link rel="prefetch" href="/assets/js/33.74cd6521.js"><link rel="prefetch" href="/assets/js/34.9d137b36.js"><link rel="prefetch" href="/assets/js/35.50b3f97d.js"><link rel="prefetch" href="/assets/js/36.1ba216f1.js"><link rel="prefetch" href="/assets/js/37.39b36aaf.js"><link rel="prefetch" href="/assets/js/38.d86ece5f.js"><link rel="prefetch" href="/assets/js/39.ed51f794.js"><link rel="prefetch" href="/assets/js/4.46657140.js"><link rel="prefetch" href="/assets/js/40.d1f5f3e3.js"><link rel="prefetch" href="/assets/js/41.cfb412eb.js"><link rel="prefetch" href="/assets/js/42.4e699448.js"><link rel="prefetch" href="/assets/js/43.e22ec204.js"><link rel="prefetch" href="/assets/js/44.0421ffff.js"><link rel="prefetch" href="/assets/js/45.58b817ec.js"><link rel="prefetch" href="/assets/js/46.541083b5.js"><link rel="prefetch" href="/assets/js/5.12d27dc6.js"><link rel="prefetch" href="/assets/js/6.25c40935.js"><link rel="prefetch" href="/assets/js/7.0b9bcdd6.js"><link rel="prefetch" href="/assets/js/8.c8621244.js"><link rel="prefetch" href="/assets/js/9.5e4b7b3b.js">
    <link rel="stylesheet" href="/assets/css/0.styles.ef148202.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">Keep learning</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">Home</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">Home</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/haskell/" class="sidebar-link">简介</a></li><li><a href="/haskell/01.types.html" class="sidebar-link">基础类型</a></li><li><a href="/haskell/02.typeclass.html" class="sidebar-link">类型签名</a></li><li><a href="/haskell/03.function.html" class="sidebar-link">函数语法</a></li><li><a href="/haskell/04.recursion.html" class="sidebar-link">递归</a></li><li><a href="/haskell/05.high-order.html" class="sidebar-link">高阶函数</a></li><li><a href="/haskell/06.module.html" class="sidebar-link">模块</a></li><li><a href="/haskell/07.build-typeclass.html" class="sidebar-link">构建 类型 类型类</a></li><li><a href="/haskell/08.input-output.html" class="active sidebar-link">输入输出</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/haskell/08.input-output.html#hello-world" class="sidebar-link">hello world</a></li><li class="sidebar-sub-header"><a href="/haskell/08.input-output.html#do-block" class="sidebar-link">do block</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/haskell/08.input-output.html#取值" class="sidebar-link">取值</a></li><li class="sidebar-sub-header"><a href="/haskell/08.input-output.html#return" class="sidebar-link">return</a></li></ul></li><li class="sidebar-sub-header"><a href="/haskell/08.input-output.html#putstr-putchar-print" class="sidebar-link">putStr putChar print</a></li><li class="sidebar-sub-header"><a href="/haskell/08.input-output.html#getchar" class="sidebar-link">getChar</a></li><li class="sidebar-sub-header"><a href="/haskell/08.input-output.html#sequence-mapm-mapm" class="sidebar-link">sequence mapM mapM_</a></li><li class="sidebar-sub-header"><a href="/haskell/08.input-output.html#forever" class="sidebar-link">forever</a></li><li class="sidebar-sub-header"><a href="/haskell/08.input-output.html#文件与字符流" class="sidebar-link">文件与字符流</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/haskell/08.input-output.html#getcontents" class="sidebar-link">getContents</a></li><li class="sidebar-sub-header"><a href="/haskell/08.input-output.html#interact" class="sidebar-link">interact</a></li><li class="sidebar-sub-header"><a href="/haskell/08.input-output.html#标准输入-输出" class="sidebar-link">标准输入/输出</a></li></ul></li></ul></li></ul> </div> <div class="page"> <div class="content"><h1 id="输入输出"><a href="#输入输出" aria-hidden="true" class="header-anchor">#</a> 输入输出</h1> <p>由于haskell 是一门纯函数式编程语言，函数不能够去改变状态的。 函数唯一能做的就是根据参数返回结果，如果用相同参数去调用同一个函数两次得到的结果是相同的。这在命令式语言中看起来是非常大的限制，但是在函数式给我们带来了很多的益处。</p> <p>但是同时这也给我们带来了一个问题，我们无法改变现实世界的状态，比如打印一个计算结果。不过haskell设计了一个非常聪明的系统来处理有副作用的函数，它漂亮地将我们的程序区分成纯粹跟非纯粹两部分，非纯粹的部分负责跟键盘还有屏幕沟通。有了这种机制，在跟外界沟通的同时，我们还是能够有效运用纯粹所带来的好处，像是惰性求值、容错性跟模块性。</p> <h2 id="hello-world"><a href="#hello-world" aria-hidden="true" class="header-anchor">#</a> hello world</h2> <p>我们可以创建一个文件，包含以下内容</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token string">&quot;hello, world&quot;</span>
</code></pre></div><p>然后通过ghc编译</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token operator">$</span> <span class="token hvariable">ghc</span> <span class="token comment">--make helloworld</span>
<span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">of</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token constant">Compiling</span> <span class="token constant">Main</span>                 <span class="token punctuation">(</span> <span class="token hvariable">helloworld</span><span class="token punctuation">.</span><span class="token hvariable">hs</span><span class="token punctuation">,</span> <span class="token hvariable">hellowowlrd</span><span class="token punctuation">.</span><span class="token hvariable">o</span> <span class="token punctuation">)</span>
<span class="token constant">Linking</span> <span class="token hvariable">helloworld</span> <span class="token operator">...</span>
</code></pre></div><p>最后在运行, 最后将打印出字串到屏幕的程序</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token operator">$</span> <span class="token operator">./</span><span class="token hvariable">helloworld</span>
<span class="token hvariable">hello</span><span class="token punctuation">,</span> <span class="token hvariable">world</span>
</code></pre></div><p>putStrLn 用于向屏幕打印值， 它接受一个String 类型的参数，返回一个IO action， 这个IO action 包含了一个 （）形态即 Tuple</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token builtin">putStrLn</span>
<span class="token builtin">putStrLn</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token builtin">putStrLn</span> <span class="token string">&quot;hello, world&quot;</span>
<span class="token builtin">putStrLn</span> <span class="token string">&quot;hello, world&quot;</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>

</code></pre></div><p>一个 I/O action 是一个会造成副作用的动作，常是指读取输入或输出到屏幕，同时也代表会回传某些值。在屏幕打印出几个字串并没有什么有意义的回传值可言，所以这边用一个 () 来代表。 一个 I/O action 会在我们把它绑定到 main 这个名字并且执行程序的时候触发。</p> <h2 id="do-block"><a href="#do-block" aria-hidden="true" class="header-anchor">#</a> do block</h2> <p>把整个程序限制在只能有一个 I/O action 看似是个极大的限制。这就是为什么我们需要 do 表示法来将所有 I/O action 绑成一个。来看看下面这个例子。</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token builtin">putStrLn</span> <span class="token string">&quot;Hello, what's your name?&quot;</span>
    <span class="token hvariable">name</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token string">&quot;Hey &quot;</span> <span class="token operator">++</span> <span class="token hvariable">name</span> <span class="token operator">++</span> <span class="token string">&quot;, you rock!&quot;</span><span class="token punctuation">)</span>
</code></pre></div><p>程序每一步都是一个 I/O action。将所有 I/O action 用 do 绑在一起变成了一个大的 I/O action
这个大的 I/O action 的类型是 IO ()，这是由最后一个 I/O action 所决定的。按照惯例，我们通常不会把 main 的型态在程序中写出来。</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token builtin">getLine</span>
<span class="token builtin">getLine</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token constant">String</span>
</code></pre></div><h3 id="取值"><a href="#取值" aria-hidden="true" class="header-anchor">#</a> 取值</h3> <p>getLine 是一个回传 String 的 I/O action, 它会等待用户的输入。<br>
name &lt;- getLine 这句的作用是执行一个 I/O action getLine 并将它的结果绑定到 name。
要获得 I/O的数据唯一办法就是用 &lt;-， 要从 I/O action 拿出某些数据，就一定同时要在另一个 I/O action 中，这就是 Haskell 如何分开纯跟不纯的程序的方法。</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">foo</span> <span class="token operator">&lt;-</span> <span class="token builtin">putStrLn</span> <span class="token string">&quot;Hello, what's your name?&quot;</span>
    <span class="token hvariable">name</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token string">&quot;Hey &quot;</span> <span class="token operator">++</span> <span class="token hvariable">name</span> <span class="token operator">++</span> <span class="token string">&quot;, you rock!&quot;</span><span class="token punctuation">)</span>
</code></pre></div><p>每个 I/O action 都有一个值封装在里面，另外最后一个 action 不能绑定任何名字。
foo 只会有一个 () 的值，所以绑定到 foo 这个名字似乎是多余的，所以我们宁愿写成 putStrLn something</p> <p>你能够在 do blocks 中使用 let 绑定</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token import_statement"><span class="token keyword">import</span> Data.Char</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token builtin">putStrLn</span> <span class="token string">&quot;What's your first name?&quot;</span>
    <span class="token hvariable">firstName</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token builtin">putStrLn</span> <span class="token string">&quot;What's your last name?&quot;</span>
    <span class="token hvariable">lastName</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token keyword">let</span> <span class="token hvariable">bigFirstName</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token hvariable">firstName</span>
        <span class="token hvariable">bigLastName</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token hvariable">lastName</span>
    <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">&quot;hey &quot;</span> <span class="token operator">++</span> <span class="token hvariable">bigFirstName</span> <span class="token operator">++</span> <span class="token string">&quot; &quot;</span> <span class="token operator">++</span> <span class="token hvariable">bigLastName</span> <span class="token operator">++</span> <span class="token string">&quot;, how are you?&quot;</span>
</code></pre></div><p>当你要绑定 I/O actions 的结果时用 &lt;-，而对于纯粹的 expression 使用 let 绑定。对于错误的 let firstName = getLine，我们只不过是把 getLine 这个 I/O actions 给了一个不同的名字罢了， 其实可以将IO 理解为一个容器，它负责存放我们与外界交互的操作</p> <p>现在我们来写一个会一行一行不断地读取输入，并将读进来的字反过来输出到屏幕上的程序。程序会在输入空白行的时候停止。</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">line</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token keyword">if</span> <span class="token builtin">null</span> <span class="token hvariable">line</span>
        <span class="token keyword">then</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span> <span class="token keyword">do</span>
            <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token hvariable">reverseWords</span> <span class="token hvariable">line</span>
            <span class="token hvariable">main</span>

<span class="token hvariable">reverseWords</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">reverseWords</span> <span class="token operator">=</span> <span class="token builtin">unwords</span><span class="token operator"> . </span><span class="token builtin">map</span> <span class="token builtin">reverse</span><span class="token operator"> . </span><span class="token builtin">words</span>
</code></pre></div><p>我们用 getLine 从终端读取了一行，并把这行输入取名叫 line。然后接着一个条件式 expression。当 if 的条件是 true （也就是输入了一个空白行），我们便执行一个 I/O action，如果 if 的条件是 false，那 else 底下的 I/O action 被执行,由于我们在 else 中只能有一个 I/O action，所以我们用 do 来将两个 I/O actions 绑成一个,</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token keyword">do</span>
    <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token hvariable">reverseWords</span> <span class="token hvariable">line</span>
    <span class="token hvariable">main</span><span class="token punctuation">)</span>
</code></pre></div><p>在 do block 里面，我们依序调用了 getLine 以及 reverseWords， 然后递归调用了 main，
由于 main 也是一个 I/O action,调用 main 也就代表我们回到程序的起点。</p> <h3 id="return"><a href="#return" aria-hidden="true" class="header-anchor">#</a> return</h3> <p>then 的区块即 then return ()被执行时， 这里 return 在 Haskell 里面的意义跟其它语言的 return 完全不同的。
在 Haskell 中，它的作用是利用某个 pure value 造出 I/O action， 相当于我们把值又装进了IO 容器。</p> <p>在 I/O do block 中放一个 return 并不会结束执行。像下面这个程序会执行到底。</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token builtin">return</span> <span class="token string">&quot;HAHAHA&quot;</span>
    <span class="token hvariable">line</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token builtin">return</span> <span class="token string">&quot;BLAH BLAH BLAH&quot;</span>
    <span class="token builtin">return</span> <span class="token number">4</span>
    <span class="token builtin">putStrLn</span> <span class="token hvariable">line</span>
</code></pre></div><p>我们能用 &lt;- 与 return 来达到绑定名称的目的。return 与 &lt;- 作用相反。return 把 value 装进盒子中，而 &lt;- 将 value 从盒子拿出来，并绑定一个名称, 不过这样做显得有些多余，应为 你可以用 let 绑定</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token builtin">return</span> <span class="token string">&quot;hell&quot;</span>
    <span class="token hvariable">b</span> <span class="token operator">&lt;-</span> <span class="token builtin">return</span> <span class="token string">&quot;yeah!&quot;</span>
    <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token hvariable">a</span> <span class="token operator">++</span> <span class="token string">&quot; &quot;</span> <span class="token operator">++</span> <span class="token hvariable">b</span>
</code></pre></div><h2 id="putstr-putchar-print"><a href="#putstr-putchar-print" aria-hidden="true" class="header-anchor">#</a> putStr putChar print</h2> <p>在除了 putStrLn 之外，还有很多可以处理 IO 的函数。</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token builtin">putStr</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token builtin">putChar</span> <span class="token operator">::</span> <span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>putStr 的边界条件是空字串，所以假设我们打印一个空字串，那它只是回传一个什么都不做的 I/O action，像 return ()。如果打印的不是空字串，那就先用 putChar 打印出字串的第一个字符，然后再用 putStr 打印出字串剩下部份。</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token builtin">print</span> <span class="token operator">::</span> <span class="token constant">Show</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>print 接受任何是 Show typeclass 的 instance 的型态的值，这代表我们知道如何用字串表示它，调用 show 来将值变成字串然后将其输出到终端上。它相当于是 putStrLn . show 的组合, GHCI 实际上就是用了 print 来将这些值输出到终端</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span> <span class="token builtin">print</span> <span class="token constant">True</span>
          <span class="token builtin">print</span> <span class="token number">2</span>
          <span class="token builtin">print</span> <span class="token string">&quot;haha&quot;</span>
          <span class="token builtin">print</span> <span class="token number">3.2</span>
          <span class="token builtin">print</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
</code></pre></div><div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">print_test</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token constant">True</span>
<span class="token number">2</span>
<span class="token string">&quot;haha&quot;</span>
<span class="token number">3.2</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
</code></pre></div><h2 id="getchar"><a href="#getchar" aria-hidden="true" class="header-anchor">#</a> getChar</h2> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token builtin">getChar</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token constant">Char</span>
</code></pre></div><p>getChar 是一个从输入读进一个字符的 I/O action</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token import_statement"><span class="token keyword">import</span> Control.Monad</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">c</span> <span class="token operator">&lt;-</span> <span class="token builtin">getChar</span>
    <span class="token hvariable">when</span> <span class="token punctuation">(</span><span class="token hvariable">c</span> <span class="token operator">/=</span> <span class="token char">' '</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token keyword">do</span>
        <span class="token builtin">putChar</span> <span class="token hvariable">c</span>
        <span class="token hvariable">main</span>
</code></pre></div><p>when 这函数可以在 Control.Monad 中找到它, 它看起来像一个控制流的 判断语句， 但它实际上是一个函数， 值是 True，便放回给它的 I/O action。如果值是 False 放回 return ()。 它相当于是 if something then do some I/O action else return ()</p> <h2 id="sequence-mapm-mapm"><a href="#sequence-mapm-mapm" aria-hidden="true" class="header-anchor">#</a> sequence mapM mapM_</h2> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token builtin">sequence</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">IO</span> <span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token hvariable">b</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token hvariable">c</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token builtin">print</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token hvariable">c</span><span class="token punctuation">]</span>

<span class="token comment">-- 用 sequence 可以改成</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">rs</span> <span class="token operator">&lt;-</span> <span class="token builtin">sequence</span> <span class="token punctuation">[</span><span class="token builtin">getLine</span><span class="token punctuation">,</span> <span class="token builtin">getLine</span><span class="token punctuation">,</span> <span class="token builtin">getLine</span><span class="token punctuation">]</span>
    <span class="token builtin">print</span> <span class="token hvariable">rs</span>
</code></pre></div><p>sequence 接受一串 I/O action，并回传一个会依序执行它们的 I/O action</p> <p>一个常见的使用方式是我们将 print 或 putStrLn 之类的函数 map 到串列上。map print [1,2,3,4] 这个动作并不会产生一个 I/O action，而是一串 I/O action，就像是 [print 1, print 2, print 3, print 4]。如果我们将一串 I/O action 变成一个 I/O action，我们必须用 sequence</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">sequence</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token builtin">print</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">1</span>
<span class="token number">2</span>
<span class="token number">3</span>
<span class="token number">4</span>
<span class="token number">5</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code></pre></div><p>由于 先map 再 sequence 这个动作太常用了，所以有一些函数在函式库中 mapM 跟 mapM_, mapM_的区别是，它会把运算的结果丢掉，在我们不关心 I/O action 结果的情况下，mapM_ 是最常被使用的。</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">mapM</span> <span class="token builtin">print</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token number">1</span>
<span class="token number">2</span>
<span class="token number">3</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">mapM_</span> <span class="token builtin">print</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token number">1</span>
<span class="token number">2</span>
<span class="token number">3</span>
</code></pre></div><h2 id="forever"><a href="#forever" aria-hidden="true" class="header-anchor">#</a> forever</h2> <p>forever 接受一个 I/O action 并回传一个永远作同一件事的 I/O action。你可以在 Control.Monad 中找到它。
下面的程序会不断地要用户输入些东西，并把输入的东西转成大写输出到屏幕上。</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token import_statement"><span class="token keyword">import</span> Control.Monad</span>
<span class="token import_statement"><span class="token keyword">import</span> Data.Char</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token hvariable">forever</span> <span class="token operator">$</span> <span class="token keyword">do</span>
    <span class="token builtin">putStr</span> <span class="token string">&quot;Give me some input: &quot;</span>
    <span class="token hvariable">l</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token hvariable">l</span>
</code></pre></div><p>在 Control.Monad 中的 forM 跟 mapM 的作用一样，只是参数的顺序相反而已。第一个参数是串列，而第二个则是函数</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token import_statement"><span class="token keyword">import</span> Control.Monad</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">colors</span> <span class="token operator">&lt;-</span> <span class="token hvariable">forM</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token keyword">do</span>
        <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">&quot;Which color do you associate with the number &quot;</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">a</span> <span class="token operator">++</span> <span class="token string">&quot;?&quot;</span>
        <span class="token hvariable">color</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
        <span class="token builtin">return</span> <span class="token hvariable">color</span><span class="token punctuation">)</span>
    <span class="token builtin">putStrLn</span> <span class="token string">&quot;The colors that you associate with 1, 2, 3 and 4 are: &quot;</span>
    <span class="token builtin">mapM</span> <span class="token builtin">putStrLn</span> <span class="token hvariable">colors</span>
</code></pre></div><p>(\a -&gt; do ...) 是接受一个数字并回传一个 I/O action 的函数, 可以把 forM 的意思想成将串列中的每个元素作成一个 I/O action。至于每个 I/O action 实际作什么就要看原本的元素是什么。然后，执行这些 I/O action 并将结果绑定到某个名称上。或是直接将结果忽略掉。</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">from_test</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token constant">Which</span> <span class="token hvariable">color</span> <span class="token keyword">do</span> <span class="token hvariable">you</span> <span class="token hvariable">associate</span> <span class="token hvariable">with</span> <span class="token hvariable">the</span> <span class="token hvariable">number</span> <span class="token number">1</span><span class="token operator">?</span>
<span class="token hvariable">white</span>
<span class="token constant">Which</span> <span class="token hvariable">color</span> <span class="token keyword">do</span> <span class="token hvariable">you</span> <span class="token hvariable">associate</span> <span class="token hvariable">with</span> <span class="token hvariable">the</span> <span class="token hvariable">number</span> <span class="token number">2</span><span class="token operator">?</span>
<span class="token hvariable">blue</span>
<span class="token constant">Which</span> <span class="token hvariable">color</span> <span class="token keyword">do</span> <span class="token hvariable">you</span> <span class="token hvariable">associate</span> <span class="token hvariable">with</span> <span class="token hvariable">the</span> <span class="token hvariable">number</span> <span class="token number">3</span><span class="token operator">?</span>
<span class="token hvariable">red</span>
<span class="token constant">Which</span> <span class="token hvariable">color</span> <span class="token keyword">do</span> <span class="token hvariable">you</span> <span class="token hvariable">associate</span> <span class="token hvariable">with</span> <span class="token hvariable">the</span> <span class="token hvariable">number</span> <span class="token number">4</span><span class="token operator">?</span>
<span class="token hvariable">orange</span>
<span class="token constant">The</span> <span class="token hvariable">colors</span> <span class="token hvariable">that</span> <span class="token hvariable">you</span> <span class="token hvariable">associate</span> <span class="token hvariable">with</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token builtin">and</span> <span class="token number">4</span> <span class="token hvariable">are</span><span class="token operator">:</span>
<span class="token hvariable">white</span>
<span class="token hvariable">blue</span>
<span class="token hvariable">red</span>
<span class="token hvariable">orange</span>
</code></pre></div><p>其实我们也不是一定要用到 forM，只是用了 forM 程序会比较容易理解。正常来讲是我们需要在 map 跟 sequence 的时候定义 I/O action 的时候使用 forM，同样地，我们也可以将最后一行写成 forM colors putStrLn。</p> <p>不要把像是 putStrLn 的函式想成接受字串并输出到屏幕。要想成一个函式接受字串并回传一个 I/O action。当 I/O action 被执行的时候，会漂亮地打印出你想要的东西。</p> <h2 id="文件与字符流"><a href="#文件与字符流" aria-hidden="true" class="header-anchor">#</a> 文件与字符流</h2> <h3 id="getcontents"><a href="#getcontents" aria-hidden="true" class="header-anchor">#</a> getContents</h3> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token builtin">getContents</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token constant">String</span>
</code></pre></div><p>getContents 是一个从标准输入读取直到 end-of-file 字符的 I/O action, getContents 是惰性 I/O (Lazy I/O)。当我们写了 foo &lt;- getContents，他并不会马上读取所有输入，将他们存在 memory 里面。他只有当你真的需要输入数据的时候才会读取。</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">contents</span> <span class="token operator">&lt;-</span> <span class="token builtin">getContents</span>
    <span class="token builtin">putStr</span> <span class="token punctuation">(</span><span class="token hvariable">shortLinesOnly</span> <span class="token hvariable">contents</span><span class="token punctuation">)</span>

<span class="token hvariable">shortLinesOnly</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">shortLinesOnly</span> <span class="token hvariable">input</span> <span class="token operator">=</span>
    <span class="token keyword">let</span> <span class="token hvariable">allLines</span> <span class="token operator">=</span> <span class="token builtin">lines</span> <span class="token hvariable">input</span>
        <span class="token hvariable">shortLines</span> <span class="token operator">=</span> <span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">line</span> <span class="token operator">-&gt;</span> <span class="token builtin">length</span> <span class="token hvariable">line</span> <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token hvariable">allLines</span>
        <span class="token hvariable">result</span> <span class="token operator">=</span> <span class="token builtin">unlines</span> <span class="token hvariable">shortLines</span>
    <span class="token keyword">in</span> <span class="token hvariable">result</span>
</code></pre></div><p>程序读取输入，并打印出少于十个字符的行。<br>
比如 &quot;short\nlooooooooooooooong\nshort again&quot;， 这字串有三行用 lines 把字串分成 [&quot;short&quot;, &quot;looooooooooooooong&quot;, &quot;short again&quot;]， 然后过滤这些字串 得到[&quot;short&quot;, &quot;short again&quot;]，最后用 unlines 把这些字串用换行接起来，形成 &quot;short\nshort again&quot;</p> <h3 id="interact"><a href="#interact" aria-hidden="true" class="header-anchor">#</a> interact</h3> <p>由于上面这个过程十分常用，所以创建了 interact 函数。 interact 接受一个 String -&gt; String ，并返回 I/O action。</p> <div class="language-haskell extra-class"><pre class="language-haskell"><code><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">interact</span> <span class="token hvariable">shortLinesOnly</span>

<span class="token hvariable">shortLinesOnly</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">shortLinesOnly</span> <span class="token hvariable">input</span> <span class="token operator">=</span>
    <span class="token keyword">let</span> <span class="token hvariable">allLines</span> <span class="token operator">=</span> <span class="token builtin">lines</span> <span class="token hvariable">input</span>
        <span class="token hvariable">shortLines</span> <span class="token operator">=</span> <span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">line</span> <span class="token operator">-&gt;</span> <span class="token builtin">length</span> <span class="token hvariable">line</span> <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token hvariable">allLines</span>
        <span class="token hvariable">result</span> <span class="token operator">=</span> <span class="token builtin">unlines</span> <span class="token hvariable">shortLines</span>
    <span class="token keyword">in</span> <span class="token hvariable">result</span>

<span class="token comment">-- 还可以简化为</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">interact</span> <span class="token operator">$</span> <span class="token builtin">unlines</span><span class="token operator"> . </span><span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token operator"> . </span><span class="token builtin">length</span><span class="token punctuation">)</span><span class="token operator"> . </span><span class="token builtin">lines</span>
</code></pre></div><h3 id="标准输入-输出"><a href="#标准输入-输出" aria-hidden="true" class="header-anchor">#</a> 标准输入/输出</h3></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/haskell/07.build-typeclass.html" class="prev">
          构建 类型 类型类
        </a></span> <!----></p></div> </div> <!----></div></div>
    <script src="/assets/js/app.67e7f428.js" defer></script><script src="/assets/js/24.4ebab5c7.js" defer></script>
  </body>
</html>
