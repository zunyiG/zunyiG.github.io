(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{177:function(_,v,e){"use strict";e.r(v);var a=e(0),t=Object(a.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var _=this,v=_.$createElement,e=_._self._c||v;return e("div",{staticClass:"content"},[e("h1",{attrs:{id:"程序设计语言—实践之路"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#程序设计语言—实践之路","aria-hidden":"true"}},[_._v("#")]),_._v(" 程序设计语言—实践之路")]),_._v(" "),e("h2",{attrs:{id:"程序设计语言的谱系"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#程序设计语言的谱系","aria-hidden":"true"}},[_._v("#")]),_._v(" 程序设计语言的谱系")]),_._v(" "),e("ul",[e("li",[e("p",[_._v("函数式 采用一种基于递归表示的函数定义计算模型。它的灵感来自于 lamubda 演算，在本质上，程序被看作是一种从输入到输出的函数，基于最简单的函数，通过一种逐步精化的方式定义。代表语言有 Lisp ML Haskell")])]),_._v(" "),e("li",[e("p",[_._v("数据流 语言将计算看作一些基本功能节点之间流动的信息流。这些语言提供了一种内在的并行模型：节点有输入的单词到达触发，能够并发操作。代表语言有 Id，Val")])]),_._v(" "),e("li",[e("p",[_._v("逻辑式 或基于限制的语言有命题逻辑得到灵感，它们把计算看作是通过一种目标制导的搜索，设法通过逻辑规则找出满足特定关系的值")])]),_._v(" "),e("li",[e("p",[_._v("冯若依曼 语言的基础是语句（特别是赋值），它们通过修改存储器里的值去的方式去影响后续的计算。代表语言包括 Frotran Pascal Basic C 等")])]),_._v(" "),e("li",[e("p",[_._v("面向对象 语言并不是把计算描绘为一个处理器在一个存储器上的操作，而是看作一些比较独立的对象之间的相互作用，每个对象都有其自身的内部状态，以及管理这些状态的可执行函数")])])]),_._v(" "),e("h2",{attrs:{id:"为什么要研究语言设计"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为什么要研究语言设计","aria-hidden":"true"}},[_._v("#")]),_._v(" 为什么要研究语言设计")]),_._v(" "),e("p",[_._v("一些基本概念是程序设计语言的基础，比如： 类型、控制( 迭代/选择/递归/非确定性/并发 ) 、抽象和命名，从这些语言特性出发去思考问题，将是我们更容易去把握语言的语法和语义。 对于自然语言的情况也类似，掌握了有关语法的知识，能使我们更容易的学习一门外语。")]),_._v(" "),e("ul",[e("li",[_._v("理解那些比较困难的特征")]),_._v(" "),e("li",[_._v("从不同的可能性中选择适当的选择适当的去表述事物")]),_._v(" "),e("li",[_._v("更好的使用排错系统、汇编器、连接器等其它相关工具")]),_._v(" "),e("li",[_._v("在缺乏某些有用特征的语言里去模拟这些特征")])]),_._v(" "),e("h2",{attrs:{id:"编译和解释"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#编译和解释","aria-hidden":"true"}},[_._v("#")]),_._v(" 编译和解释")]),_._v(" "),e("p",[_._v("第一种方式：")]),_._v(" "),e("p",[e("code",[_._v("源程序")]),_._v(" => "),e("code",[_._v("编译器")]),_._v(" => "),e("code",[_._v("目标程序")]),e("br"),_._v(" "),e("code",[_._v("输入")]),_._v(" => "),e("code",[_._v("目标程序")]),_._v(" => "),e("code",[_._v("输出")])]),_._v(" "),e("p",[_._v("另一种方式:\n"),e("code",[_._v("源程序")]),_._v(" 、 "),e("code",[_._v("输入")]),_._v(" => "),e("code",[_._v("解释器")]),_._v(" => "),e("code",[_._v("输出")])]),_._v(" "),e("p",[_._v("一般来说，与编译器相比，解释器可以带来更大的灵活性，更好的错误消息，更容易的拍错 等等"),e("br"),_._v("\n与之相对的是，编译方式通常能带来更好的性能")]),_._v(" "),e("p",[_._v("然而还有很多语言是采用的两者相结合的模式")]),_._v(" "),e("p",[e("code",[_._v("源程序")]),_._v(" => "),e("code",[_._v("翻译器")]),_._v(" => "),e("code",[_._v("中间语言程序")]),e("br"),_._v(" "),e("code",[_._v("中间语言程序")]),_._v(" 、 "),e("code",[_._v("输入")]),_._v(" => "),e("code",[_._v("虚拟机")]),_._v(" => "),e("code",[_._v("输出")])])])}],!1,null,null,null);v.default=t.exports}}]);